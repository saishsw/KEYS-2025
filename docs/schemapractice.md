# Extracting Schema Commenting Practice
Note: The code was generated by Gemini 2.5 Flash; I wrote the comments to strenghten my understanding of the code. The lines following "#" are the comments.

    import pandas as pd
    import duckdb
    import datetime

    # Creating a function that generates a DataFrame with test data - in the final project this will replaced with reading a file of data
    def generate_test_data():
        data = {
            'product_id': [101, 102, 103, 104, 105],
            'product_name': ['Laptop', 'Mouse', 'Keyboard', 'Monitor', 'Webcam'],
            'price': [1200.50, 25.99, 75.00, 300.75, 49.99],
            'in_stock': [True, True, False, True, False],
            'region': ['North', 'South', 'East', 'West', 'North'],
            'order_date': [
                datetime.date(2023, 1, 15),
                datetime.date(2023, 1, 16),
                datetime.date(2023, 2, 1),
                datetime.date(2023, 2, 5),
                datetime.date(2023, 3, 10)
            ]
        }
        # Create a DataFrame using the defined data above
        df = pd.DataFrame(data)
        # Returns the top 5 rows of the DataFrame
        print(df.head())
        # Returns the DataFrame - all in the same function
        return df
    # Creates a new function that transfer the DataFrame to DuckDB
    def transfer_data_to_duckdb(df, table_name='my_test_data'):
        # Makes an connection object that connects to an in-memory database - i.e it uses RAM
        con_object = duckdb.connect(database=':memory:')
        # This directly transfers the DataFrame to DuckDB, a neat feature of DuckDB and quick data integration with python.  
        con_object.register(table_name, df)
        # Prints the number of rows inserted into the table - SELECT COUNT - SQL Query
        print(f"Data loaded into DuckDB. Rows inserted: {con_object.execute(f'SELECT COUNT(*) FROM {table_name}').fetchone()[0]}")
        # This function returns the connection object
        return con_object

    # Function to get the schema of the DuckDB table
    def get_schema(con, table_name):
        # This is a SQL query via DuckDB to get column names and data types in our specific table
        schema_query = f"""
        SELECT
            column_name,
            data_type
        FROM    
            information_schema.columns
        WHERE
            table_name = '{table_name}'
        """
        # This command actually executes the SQL query and fetches all results with the "fetchall()" method
        schema_results = con.execute(schema_query).fetchall()
        # This creates a dictionary as schema_dict as the key and the table name and columns as values
        schema_dict = {
            "table_name": table_name,
            "columns": []
     }
        # This loops through the results and appends each column name and data type to the schema_dict
        for col_name, data_type in schema_results:
            schema_dict["columns"].append({
                "column_name": col_name,
                "data_type": data_type
            })
        return schema_dict

    # This ensures that the code is reproducible as it runs only when it is executired directly and not an imported module - as only when it is             executed directly does __name__ = "__main__"
    if __name__ == "__main__":

        dummy_df = generate_test_data()


        duckdb_conn = transfer_data_to_duckdb(dummy_df, table_name="product_sales")


        extracted_schema = get_schema(duckdb_conn, "product_sales")

        # Prints the extracted schema
        print("\n--- Extracted Schema ---")
        print(f"Table Name: {extracted_schema['table_name']}")
        print("Columns:")
        for col in extracted_schema['columns']:
            # Prints each column and its duckdb data type
            print(f"  - {col['column_name']} (DuckDB Type: {col['data_type']})")

        # Closes the DuckDB in memory connection
        duckdb_conn.close()
        print("\nDuckDB connection closed.")

